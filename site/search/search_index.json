{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Family Tree Chatbot How It Works The chatbot.pl file serves as the interactive interface. It integrates querying and statement functionalities, allowing users to both retrieve information about familial relationships and add new data to the system. Module Integration Loading Modules : :- consult(utils/logic). :- use_module(utils/statements). :- use_module(utils/questions). These lines load the necessary modules for logic handling, statement processing, and query functionalities, making them accessible to the chatbot. Entry Point start/0 Predicate : Initiates the chatbot, welcoming users and entering the main loop for command input and processing. Main Loop main_loop/0 Predicate : Manages the interactive session where user input is continuously read and processed until the user types \"quit\". Processing User Input process_input/1 Predicate : Parses the user input into a list of words and then executes the corresponding command. parse_input/2 Predicate : Splits the input string into a list of words, facilitating further processing. Executing Commands execute_command/1 Predicate : The core of the chatbot, where different commands are matched and executed. It handles a variety of commands related to querying and adding family relationships. The pattern matching in Prolog is utilized to identify and respond to specific user queries and statements. Query Commands Example : execute_command([\"Are\", Sibling1, \"and\", Sibling2, \"siblings\", \"\"]) : This pattern matches a query about whether two individuals are siblings and calls query_sibling/2 to verify this. Similar patterns are used for other family relationships like parent-child, siblings, and extended family members. Statement Commands Example : execute_command([Sibling1, \"and\", Sibling2, \"are\", \"siblings\"]) : Adds a sibling relationship between two individuals using add_sibling/2 . Other patterns follow a similar logic for different types of familial relationships, such as adding parents, children, uncles, aunts, etc. Special Cases Quit Command : Handles the \"quit\" command to exit the chatbot. Unrecognized Input : Provides a response for inputs that do not match any known pattern. Helper Functions print_* Functions : Assist in presenting query results in a readable format.","title":"Home"},{"location":"#family-tree-chatbot","text":"","title":"Family Tree Chatbot"},{"location":"#how-it-works","text":"The chatbot.pl file serves as the interactive interface. It integrates querying and statement functionalities, allowing users to both retrieve information about familial relationships and add new data to the system.","title":"How It Works"},{"location":"#module-integration","text":"Loading Modules : :- consult(utils/logic). :- use_module(utils/statements). :- use_module(utils/questions). These lines load the necessary modules for logic handling, statement processing, and query functionalities, making them accessible to the chatbot.","title":"Module Integration"},{"location":"#entry-point","text":"start/0 Predicate : Initiates the chatbot, welcoming users and entering the main loop for command input and processing.","title":"Entry Point"},{"location":"#main-loop","text":"main_loop/0 Predicate : Manages the interactive session where user input is continuously read and processed until the user types \"quit\".","title":"Main Loop"},{"location":"#processing-user-input","text":"process_input/1 Predicate : Parses the user input into a list of words and then executes the corresponding command. parse_input/2 Predicate : Splits the input string into a list of words, facilitating further processing.","title":"Processing User Input"},{"location":"#executing-commands","text":"execute_command/1 Predicate : The core of the chatbot, where different commands are matched and executed. It handles a variety of commands related to querying and adding family relationships. The pattern matching in Prolog is utilized to identify and respond to specific user queries and statements.","title":"Executing Commands"},{"location":"#query-commands","text":"Example : execute_command([\"Are\", Sibling1, \"and\", Sibling2, \"siblings\", \"\"]) : This pattern matches a query about whether two individuals are siblings and calls query_sibling/2 to verify this. Similar patterns are used for other family relationships like parent-child, siblings, and extended family members.","title":"Query Commands"},{"location":"#statement-commands","text":"Example : execute_command([Sibling1, \"and\", Sibling2, \"are\", \"siblings\"]) : Adds a sibling relationship between two individuals using add_sibling/2 . Other patterns follow a similar logic for different types of familial relationships, such as adding parents, children, uncles, aunts, etc.","title":"Statement Commands"},{"location":"#special-cases","text":"Quit Command : Handles the \"quit\" command to exit the chatbot. Unrecognized Input : Provides a response for inputs that do not match any known pattern.","title":"Special Cases"},{"location":"#helper-functions","text":"print_* Functions : Assist in presenting query results in a readable format.","title":"Helper Functions"},{"location":"logic/","text":"logic.pl This Prolog module, defines a set of predicates for modeling familial relationships and constraints on these relationships. It includes predicates for defining direct relationships (like parent, sibling, child), extended relationships (like uncle, aunt, cousin), and constraints for impossible relationships (to prevent logical inconsistencies). Predicates Module and Dynamic Declarations Module Declaration : :- module(logic, [List of predicates]). This line defines the logic module and exports the listed predicates so they can be used by other files. Dynamic Declarations : :- dynamic predicate_name/arity. These lines allow for the addition or removal of facts from the database at runtime for the listed predicates. Direct Relationship Definitions sibling(X, Y) : Purpose : Determines if X and Y are siblings. Definition : X and Y are siblings if they share a common parent and are not the same person ( X \\= Y ). brother(X, Y) : Purpose : Checks if X is a brother of Y . Definition : X is a brother of Y if X is male and a sibling of Y . sister(X, Y) : Purpose : Identifies if X is a sister of Y . Definition : X is a sister of Y if X is female and a sibling of Y . father(X, Y) : Purpose : Determines if X is the father of Y . Definition : X is the father if X is male and a parent of Y . mother(X, Y) : Purpose : Identifies if X is the mother of Y . Definition : X is the mother of Y if X is female and a parent of Y . grandfather(X, Y) : Purpose : Determines if X is the grandfather of Y . Definition : X is the grandfather of Y if X is the father of one of Y's parents. grandmother(X, Y) : Purpose : Determines if X is the grandmother of Y . Definition : X is the grandmother of Y if X is the mother of one of Y's parents. child(X, Y) : Purpose : Checks if X is a child of Y . Definition : X is a child of Y if Y is a parent of X . son(X, Y) : Purpose : Determines if X is the son of Y . Definition : X is the son of Y if X is male and a child of Y . daughter(X, Y) : Purpose : Determines if X is the daughter of Y . Definition : X is the daughter of Y if X is female and a child of Y . uncle(X, Y) : Purpose : Identifies if X is the uncle of Y . Definition : X is the uncle of Y if X is a brother of one of Y's parents. aunt(X, Y) : Purpose : Identifies if X is the aunt of Y . Definition : X is the aunt of Y if X is a sister of one of Y's parents. cousin(X, Y) : Purpose : Determines if X and Y are cousins. Definition : X and Y are cousins if a parent of X and a parent of Y are siblings. relative(X, Y) : Purpose : Checks if X and Y are relatives. Definition : X and Y are considered relatives if they are connected through a parent, child, sibling, grandparent, uncle, aunt, or cousin relationship. Impossible Relationship Definitions impossible_sibling(X, Y) : Purpose : Determines conditions where X and Y cannot logically be siblings. Definition : Includes conditions like being the same person, having different parents, or existing parent/child relationships that contradict them being siblings. impossible_brother(X, Y) : Purpose : Identifies situations where X cannot be a brother of Y . Definition : Applies if X is female or if X and Y meet the criteria of impossible_sibling . impossible_sister(X, Y) : Purpose : Determines scenarios where X cannot be a sister of Y . Definition : Applies if X is male or if X and Y are impossible_sibling s. impossible_parent(X, Y) : Purpose : Establishes conditions where X cannot be a parent of Y . Definition : Includes being the same person, Y already having different parents, or other relationships that logically prevent a parent relationship. impossible_parent(X, Y, Z) : Purpose : Defines conditions where X and Y cannot both be parents of Z . Definition : Considers cases like either parent being the same person as Z , or Z already having different parents. impossible_father(X, Y) : Purpose : Specifies when X cannot be the father of Y . Definition : Includes X being female, Y already having a father, or conditions met for impossible_parent . impossible_mother(X, Y) : Purpose : Identifies when X cannot be the mother of Y . Definition : Covers X being male, Y already having a mother, or meeting impossible_parent criteria. impossible_grandmother(X, Y) : Purpose : Defines when X cannot be the grandmother of Y . Definition : Includes X being male, already having grandmothers, or other relationships that contradict a grandmother relationship. impossible_grandfather(X, Y) : Purpose : Establishes when X cannot be the grandfather of Y . Definition : Criteria include X being female, already having grandfathers, or other contradictory relationships. impossible_child(X, Y) : Purpose : Details conditions where X cannot be a child of Y . Definition : Considerations include X being the same as Y , already having parents, or other relationships negating a child-parent relationship. impossible_son(X, Y) : Purpose : Determines when X cannot be the son of Y . Definition : Criteria include X being female or conditions met for impossible_child . impossible_daughter(X, Y) : Purpose : Specifies when X cannot be the daughter of Y . Definition : Includes X being male or meeting conditions of impossible_child . impossible_uncle(X, Y) : Purpose : Defines conditions where X cannot be an uncle of Y . Definition : Includes X being female, being the same person as Y , or not being a brother to any of Y's parents. impossible_aunt(X, Y) : Purpose : Establishes when X cannot be an aunt of Y . Definition : Criteria include X being male, being the same person as Y , or not being a sister to any of Y's parents. Helper Definitions different_parents(X, Y) : Purpose : Checks if X and Y do not share a single parent. Definition : Considers X and Y to have different parents if no parent is shared between them. already_has_parents(X) : Purpose : Determines if X already has two different parents. Definition : True if X is recorded with two distinct parents in the database. already_has_parents(X, Y) : Purpose : Checks if X has two different parents, excluding Y . Definition : True if X has two parents that are different from Y . already_has_parents(X, Y, Z) : Purpose : Determines if X cannot have two new parents Y and Z . Definition : True if X already has one parent different from Y and Z . sibling_has_different_parents(X, Y) : Purpose : Checks if X cannot be a parent of Y based on siblings of Y with different parents. Definition : True if Y has a sibling with different parents and X is not one of those parents. already_has_father(X) : Purpose : Determines if X already has a father. Definition : True if X is recorded with a father in the database. already_has_mother(X) : Purpose : Checks if X already has a mother. Definition : True if X is recorded with a mother in the database. already_has_grandmothers(X) : Purpose : Determines if X already has two different grandmothers. Definition : True if X has two distinct grandmothers recorded. already_has_grandfathers(X) : Purpose : Checks if X already has two different grandfathers. Definition : True if X has two distinct grandfathers recorded. unrelated_grandparent(X, Y) : Purpose : Determines if X cannot be a grandparent of Y . Definition : True if the parents of Y are not children of X . unrelated_uncle(X, Y) : Purpose : Checks if X cannot be an uncle of Y . Definition : True if X is not a brother to any of the parents of Y . unrelated_aunt(X, Y) : Purpose : Determines if X cannot be an aunt of Y . Definition : True if X is not a sister to any of the parents of Y .","title":"Logic"},{"location":"logic/#logicpl","text":"This Prolog module, defines a set of predicates for modeling familial relationships and constraints on these relationships. It includes predicates for defining direct relationships (like parent, sibling, child), extended relationships (like uncle, aunt, cousin), and constraints for impossible relationships (to prevent logical inconsistencies).","title":"logic.pl"},{"location":"logic/#predicates","text":"","title":"Predicates"},{"location":"logic/#module-and-dynamic-declarations","text":"Module Declaration : :- module(logic, [List of predicates]). This line defines the logic module and exports the listed predicates so they can be used by other files. Dynamic Declarations : :- dynamic predicate_name/arity. These lines allow for the addition or removal of facts from the database at runtime for the listed predicates.","title":"Module and Dynamic Declarations"},{"location":"logic/#direct-relationship-definitions","text":"sibling(X, Y) : Purpose : Determines if X and Y are siblings. Definition : X and Y are siblings if they share a common parent and are not the same person ( X \\= Y ). brother(X, Y) : Purpose : Checks if X is a brother of Y . Definition : X is a brother of Y if X is male and a sibling of Y . sister(X, Y) : Purpose : Identifies if X is a sister of Y . Definition : X is a sister of Y if X is female and a sibling of Y . father(X, Y) : Purpose : Determines if X is the father of Y . Definition : X is the father if X is male and a parent of Y . mother(X, Y) : Purpose : Identifies if X is the mother of Y . Definition : X is the mother of Y if X is female and a parent of Y . grandfather(X, Y) : Purpose : Determines if X is the grandfather of Y . Definition : X is the grandfather of Y if X is the father of one of Y's parents. grandmother(X, Y) : Purpose : Determines if X is the grandmother of Y . Definition : X is the grandmother of Y if X is the mother of one of Y's parents. child(X, Y) : Purpose : Checks if X is a child of Y . Definition : X is a child of Y if Y is a parent of X . son(X, Y) : Purpose : Determines if X is the son of Y . Definition : X is the son of Y if X is male and a child of Y . daughter(X, Y) : Purpose : Determines if X is the daughter of Y . Definition : X is the daughter of Y if X is female and a child of Y . uncle(X, Y) : Purpose : Identifies if X is the uncle of Y . Definition : X is the uncle of Y if X is a brother of one of Y's parents. aunt(X, Y) : Purpose : Identifies if X is the aunt of Y . Definition : X is the aunt of Y if X is a sister of one of Y's parents. cousin(X, Y) : Purpose : Determines if X and Y are cousins. Definition : X and Y are cousins if a parent of X and a parent of Y are siblings. relative(X, Y) : Purpose : Checks if X and Y are relatives. Definition : X and Y are considered relatives if they are connected through a parent, child, sibling, grandparent, uncle, aunt, or cousin relationship.","title":"Direct Relationship Definitions"},{"location":"logic/#impossible-relationship-definitions","text":"impossible_sibling(X, Y) : Purpose : Determines conditions where X and Y cannot logically be siblings. Definition : Includes conditions like being the same person, having different parents, or existing parent/child relationships that contradict them being siblings. impossible_brother(X, Y) : Purpose : Identifies situations where X cannot be a brother of Y . Definition : Applies if X is female or if X and Y meet the criteria of impossible_sibling . impossible_sister(X, Y) : Purpose : Determines scenarios where X cannot be a sister of Y . Definition : Applies if X is male or if X and Y are impossible_sibling s. impossible_parent(X, Y) : Purpose : Establishes conditions where X cannot be a parent of Y . Definition : Includes being the same person, Y already having different parents, or other relationships that logically prevent a parent relationship. impossible_parent(X, Y, Z) : Purpose : Defines conditions where X and Y cannot both be parents of Z . Definition : Considers cases like either parent being the same person as Z , or Z already having different parents. impossible_father(X, Y) : Purpose : Specifies when X cannot be the father of Y . Definition : Includes X being female, Y already having a father, or conditions met for impossible_parent . impossible_mother(X, Y) : Purpose : Identifies when X cannot be the mother of Y . Definition : Covers X being male, Y already having a mother, or meeting impossible_parent criteria. impossible_grandmother(X, Y) : Purpose : Defines when X cannot be the grandmother of Y . Definition : Includes X being male, already having grandmothers, or other relationships that contradict a grandmother relationship. impossible_grandfather(X, Y) : Purpose : Establishes when X cannot be the grandfather of Y . Definition : Criteria include X being female, already having grandfathers, or other contradictory relationships. impossible_child(X, Y) : Purpose : Details conditions where X cannot be a child of Y . Definition : Considerations include X being the same as Y , already having parents, or other relationships negating a child-parent relationship. impossible_son(X, Y) : Purpose : Determines when X cannot be the son of Y . Definition : Criteria include X being female or conditions met for impossible_child . impossible_daughter(X, Y) : Purpose : Specifies when X cannot be the daughter of Y . Definition : Includes X being male or meeting conditions of impossible_child . impossible_uncle(X, Y) : Purpose : Defines conditions where X cannot be an uncle of Y . Definition : Includes X being female, being the same person as Y , or not being a brother to any of Y's parents. impossible_aunt(X, Y) : Purpose : Establishes when X cannot be an aunt of Y . Definition : Criteria include X being male, being the same person as Y , or not being a sister to any of Y's parents.","title":"Impossible Relationship Definitions"},{"location":"logic/#helper-definitions","text":"different_parents(X, Y) : Purpose : Checks if X and Y do not share a single parent. Definition : Considers X and Y to have different parents if no parent is shared between them. already_has_parents(X) : Purpose : Determines if X already has two different parents. Definition : True if X is recorded with two distinct parents in the database. already_has_parents(X, Y) : Purpose : Checks if X has two different parents, excluding Y . Definition : True if X has two parents that are different from Y . already_has_parents(X, Y, Z) : Purpose : Determines if X cannot have two new parents Y and Z . Definition : True if X already has one parent different from Y and Z . sibling_has_different_parents(X, Y) : Purpose : Checks if X cannot be a parent of Y based on siblings of Y with different parents. Definition : True if Y has a sibling with different parents and X is not one of those parents. already_has_father(X) : Purpose : Determines if X already has a father. Definition : True if X is recorded with a father in the database. already_has_mother(X) : Purpose : Checks if X already has a mother. Definition : True if X is recorded with a mother in the database. already_has_grandmothers(X) : Purpose : Determines if X already has two different grandmothers. Definition : True if X has two distinct grandmothers recorded. already_has_grandfathers(X) : Purpose : Checks if X already has two different grandfathers. Definition : True if X has two distinct grandfathers recorded. unrelated_grandparent(X, Y) : Purpose : Determines if X cannot be a grandparent of Y . Definition : True if the parents of Y are not children of X . unrelated_uncle(X, Y) : Purpose : Checks if X cannot be an uncle of Y . Definition : True if X is not a brother to any of the parents of Y . unrelated_aunt(X, Y) : Purpose : Determines if X cannot be an aunt of Y . Definition : True if X is not a sister to any of the parents of Y .","title":"Helper Definitions"},{"location":"questions/","text":"questions.pl This Prolog module is designed for querying and confirming various familial relationships. It provides predicates to inquire about relationships like siblings, parents, children, and extended family members. The module facilitates the validation of these relationships based on the data in the knowledge base. Predicates Module and Dynamic Declarations Module Declaration : :- module(questions, [List of predicates]). Defines the questions module, exporting predicates for querying family relationships. Use Module Logic : :- use_module(logic). Integrates the logic module to utilize its defined relationships for queries. Query Definitions query_sibling/2 & query_sibling/1 Confirms if two individuals are siblings ( query_sibling/2 ) and lists all siblings of a given individual ( query_sibling/1 ). query_sister/2 & query_sister/1 Validates sister relationships between two individuals ( query_sister/2 ) and lists all sisters of a specified sibling ( query_sister/1 ). query_brother/2 & query_brother/1 Checks brother relationships ( query_brother/2 ) and enumerates all brothers of a given sibling ( query_brother/1 ). query_mother/2 & query_mother/1 Confirms if an individual is the mother of a child ( query_mother/2 ) and identifies the mother of a specified child ( query_mother/1 ). query_father/2 & query_father/1 Verifies father-child relationships ( query_father/2 ) and finds the father of a specific child ( query_father/1 ). query_parents/3 & query_parents/1 Validates the parentage of a child by two individuals ( query_parents/3 ) and lists the parents of a given child ( query_parents/1 ). query_grandmother/2 & query_grandfather/2 Checks for grandmother and grandfather relationships with a grandchild, respectively. query_daughter/2 & query_daughter/1 Confirms if an individual is the daughter of a parent ( query_daughter/2 ) and lists all daughters of a parent ( query_daughter/1 ). query_son/2 & query_son/1 Validates if an individual is the son of a parent ( query_son/2 ) and enumerates all sons of a parent ( query_son/1 ). query_child/2 , query_child/1 , & query_child/4 Confirms child-parent relationships ( query_child/2 ), lists all children of a parent ( query_child/1 ), and validates multiple children of the same parent ( query_child/4 ). query_uncle/2 & query_aunt/2 Determines if an individual is an uncle or aunt to a niece or nephew. query_relative/2 Establishes if two individuals are related in any familial way defined in the knowledge base. Helper Definitions print_siblings/1 Purpose and Logic : Displays a list of siblings or a message if there are none. Empty Case : When provided with an empty list ( [] ), it prints \"There are no siblings.\" Non-Empty Case : For a non-empty list, it prints \"The siblings are:\" followed by the list of siblings using print_list . print_brothers/1 Purpose and Logic : Prints a list of brothers or a message indicating the absence of brothers. Empty Case : Prints \"There are no brothers.\" for an empty list. Non-Empty Case : Outputs \"The brothers are:\" and enumerates the brothers using print_list . print_sisters/1 Purpose and Logic : Similar to print_brothers , but for listing sisters. Empty Case : Informs \"There are no sisters.\" when there are no sisters in the list. Non-Empty Case : Shows \"The sisters are:\" and the list of sisters. print_daughters/1 Purpose and Logic : Displays a list of daughters or a message if no daughters are found. Empty Case : States \"There are no daughters.\" for an empty list. Non-Empty Case : Announces \"The daughters are:\" followed by the list. print_sons/1 Purpose and Logic : Works similarly to print_daughters , but for sons. Empty Case : Indicates \"There are no sons.\" for an empty list. Non-Empty Case : Proclaims \"The sons are:\" followed by the list of sons. print_children/1 Purpose and Logic : Prints a list of children or notifies if there are none. Empty Case : Reports \"There are no children.\" when the list is empty. Non-Empty Case : Declares \"The children are:\" and then lists the children. print_list/1 Purpose and Logic : General utility function for printing any list of items. Base Case : Does nothing for an empty list, effectively ending the recursion. Recursive Case : Prints the head of the list (first element) followed by a newline, then recursively calls itself with the tail (remaining elements) of the list. Formatting : Each item is printed with a hyphen ( - ) prefix for clear list formatting.","title":"Questions"},{"location":"questions/#questionspl","text":"This Prolog module is designed for querying and confirming various familial relationships. It provides predicates to inquire about relationships like siblings, parents, children, and extended family members. The module facilitates the validation of these relationships based on the data in the knowledge base.","title":"questions.pl"},{"location":"questions/#predicates","text":"","title":"Predicates"},{"location":"questions/#module-and-dynamic-declarations","text":"Module Declaration : :- module(questions, [List of predicates]). Defines the questions module, exporting predicates for querying family relationships. Use Module Logic : :- use_module(logic). Integrates the logic module to utilize its defined relationships for queries.","title":"Module and Dynamic Declarations"},{"location":"questions/#query-definitions","text":"query_sibling/2 & query_sibling/1 Confirms if two individuals are siblings ( query_sibling/2 ) and lists all siblings of a given individual ( query_sibling/1 ). query_sister/2 & query_sister/1 Validates sister relationships between two individuals ( query_sister/2 ) and lists all sisters of a specified sibling ( query_sister/1 ). query_brother/2 & query_brother/1 Checks brother relationships ( query_brother/2 ) and enumerates all brothers of a given sibling ( query_brother/1 ). query_mother/2 & query_mother/1 Confirms if an individual is the mother of a child ( query_mother/2 ) and identifies the mother of a specified child ( query_mother/1 ). query_father/2 & query_father/1 Verifies father-child relationships ( query_father/2 ) and finds the father of a specific child ( query_father/1 ). query_parents/3 & query_parents/1 Validates the parentage of a child by two individuals ( query_parents/3 ) and lists the parents of a given child ( query_parents/1 ). query_grandmother/2 & query_grandfather/2 Checks for grandmother and grandfather relationships with a grandchild, respectively. query_daughter/2 & query_daughter/1 Confirms if an individual is the daughter of a parent ( query_daughter/2 ) and lists all daughters of a parent ( query_daughter/1 ). query_son/2 & query_son/1 Validates if an individual is the son of a parent ( query_son/2 ) and enumerates all sons of a parent ( query_son/1 ). query_child/2 , query_child/1 , & query_child/4 Confirms child-parent relationships ( query_child/2 ), lists all children of a parent ( query_child/1 ), and validates multiple children of the same parent ( query_child/4 ). query_uncle/2 & query_aunt/2 Determines if an individual is an uncle or aunt to a niece or nephew. query_relative/2 Establishes if two individuals are related in any familial way defined in the knowledge base.","title":"Query Definitions"},{"location":"questions/#helper-definitions","text":"","title":"Helper Definitions"},{"location":"questions/#print_siblings1","text":"Purpose and Logic : Displays a list of siblings or a message if there are none. Empty Case : When provided with an empty list ( [] ), it prints \"There are no siblings.\" Non-Empty Case : For a non-empty list, it prints \"The siblings are:\" followed by the list of siblings using print_list .","title":"print_siblings/1"},{"location":"questions/#print_brothers1","text":"Purpose and Logic : Prints a list of brothers or a message indicating the absence of brothers. Empty Case : Prints \"There are no brothers.\" for an empty list. Non-Empty Case : Outputs \"The brothers are:\" and enumerates the brothers using print_list .","title":"print_brothers/1"},{"location":"questions/#print_sisters1","text":"Purpose and Logic : Similar to print_brothers , but for listing sisters. Empty Case : Informs \"There are no sisters.\" when there are no sisters in the list. Non-Empty Case : Shows \"The sisters are:\" and the list of sisters.","title":"print_sisters/1"},{"location":"questions/#print_daughters1","text":"Purpose and Logic : Displays a list of daughters or a message if no daughters are found. Empty Case : States \"There are no daughters.\" for an empty list. Non-Empty Case : Announces \"The daughters are:\" followed by the list.","title":"print_daughters/1"},{"location":"questions/#print_sons1","text":"Purpose and Logic : Works similarly to print_daughters , but for sons. Empty Case : Indicates \"There are no sons.\" for an empty list. Non-Empty Case : Proclaims \"The sons are:\" followed by the list of sons.","title":"print_sons/1"},{"location":"questions/#print_children1","text":"Purpose and Logic : Prints a list of children or notifies if there are none. Empty Case : Reports \"There are no children.\" when the list is empty. Non-Empty Case : Declares \"The children are:\" and then lists the children.","title":"print_children/1"},{"location":"questions/#print_list1","text":"Purpose and Logic : General utility function for printing any list of items. Base Case : Does nothing for an empty list, effectively ending the recursion. Recursive Case : Prints the head of the list (first element) followed by a newline, then recursively calls itself with the tail (remaining elements) of the list. Formatting : Each item is printed with a hyphen ( - ) prefix for clear list formatting.","title":"print_list/1"},{"location":"statements/","text":"statements.pl This Prolog module is designed for managing and asserting various familial relationships. It provides predicates for adding relationships such as siblings, parents, children, and extended family members like uncles and aunts. The module also includes logic to check for inconsistencies or impossibilities in these relationships before asserting them. Predicates Module and Dynamic Declarations Module Declaration : :- module(statements, [List of predicates]). This line defines the statements module and exports a series of predicates that handle the addition of family relationships. Dynamic Declarations : :- dynamic checked/1. Allows the checked predicate to be dynamically updated, which is used in gender inference functions. Statement Definitions add_sibling(Sibling1, Sibling2) Checks if Sibling1 and Sibling2 are already siblings. If yes, it prints that the relationship exists. If not, it checks if such a sibling relationship is logically impossible (e.g., due to contradictory relationships). If impossible, it indicates so. If neither of these conditions is met, it asserts Sibling1 and Sibling2 as siblings in both directions ( Sibling1 as a sibling of Sibling2 and vice versa). add_brother(Brother, Sibling) First, it checks if Brother is already a brother of Sibling . If this relationship exists or is impossible, it responds accordingly. If Brother is not known to be male, it asserts his gender. Then it ensures that both Brother and Sibling are marked as siblings of each other. Finally, it tries to define genders from neutral relatives if needed. add_sister(Sister, Sibling) Similar to add_brother , but for establishing sister relationships. It asserts Sister 's gender as female if not already known. add_father(Father, Child) Checks if Father is already the father of Child . If this relationship is established or impossible, it responds accordingly. Asserts Father as male and as the parent of Child . Additionally, it handles cases where siblings have different mothers or fathers, ensuring consistency in parental relationships. add_mother(Mother, Child) Parallel to add_father but for mother relationships. It checks existing relationships, asserts gender, and handles complex family structures. add_parents(Parent1, Parent2, Child) Verifies if Parent1 and Parent2 are already parents of Child . If the relationship exists or is impossible, it indicates so. Asserts both Parent1 and Parent2 as parents of Child . add_grandmother(Grandmother, Grandchild) & add_grandfather(Grandfather, Grandchild) These predicates add grandmother and grandfather relationships, respectively. They check for existing relationships or impossibilities, assert gender, and then establish the grandparent relationship. add_daughter(Daughter, Parent) & add_son(Son, Parent) These predicates handle adding daughter or son relationships. They check for existing or impossible relationships, assert gender, and establish the parent-child relationship. add_child(Child, Parent) Checks if Child is already a child of Parent . If the relationship is established or impossible, it responds accordingly. Asserts the parent-child relationship. add_children(Children, Parent) Manages the addition of multiple children to a parent, handling each child individually. It processes lists, including handling special cases like empty strings or the word \"and.\" Each child is individually checked and added as a child of the parent. add_uncle(Uncle, NieceNephew) & add_aunt(Aunt, NieceNephew) These predicates add uncle or aunt relationships . They check for existing or impossible relationships, infer gender, and then assert the relationship. Helper Definitions define_genders_from_neutral(Parent) Purpose and Logic : Infers and asserts the gender of parents whose gender is not yet defined. Check & Mark : First, it checks if Parent has already been processed to avoid redundant checks. If not already checked, it marks Parent as checked. Find Other Parents : Retrieves all co-parents of Parent's children. Gender Inference : If any co-parent is known to be male, it invokes define_genders for further inference. If a co-parent is female, it calls define_genders_from_mother . If gender is unknown, no action is taken for that co-parent. Recursive Call : Applies the same logic to all retrieved co-parents, ensuring comprehensive gender inference across the family tree. define_genders(Father) Purpose and Logic : Infers and asserts the gender of mothers related to a known male parent. Male Confirmation : Confirms that Father is male. Find Mothers : Identifies all co-parents of Father's children who are not yet identified as male or female. Assert Female : Asserts these co-parents as female. Recursive Gender Inference : Calls define_genders_from_mother for each co-parent to further infer genders in the family tree. define_genders_from_mother(Mother) Purpose and Logic : Similar to define_genders , but starts with a known female parent and infers male gender for co-parents. Female Confirmation : Ensures that Mother is female. Find Fathers : Identifies co-parents of Mother's children with an undefined gender. Assert Male : Asserts these co-parents as male. Recursive Gender Inference : Invokes define_genders for each male co-parent for further inference. assert_as_male(Person) and assert_as_female(Person) Purpose and Logic : These helper predicates assert a person as male or female, respectively, if their gender is not already defined. Check and Assert : Each predicate checks if the person's gender is not already defined. If undefined, it asserts the person as male or female. No Redundancy : Ensures no redundant assertions are made if the gender is already known.","title":"Statements"},{"location":"statements/#statementspl","text":"This Prolog module is designed for managing and asserting various familial relationships. It provides predicates for adding relationships such as siblings, parents, children, and extended family members like uncles and aunts. The module also includes logic to check for inconsistencies or impossibilities in these relationships before asserting them.","title":"statements.pl"},{"location":"statements/#predicates","text":"","title":"Predicates"},{"location":"statements/#module-and-dynamic-declarations","text":"Module Declaration : :- module(statements, [List of predicates]). This line defines the statements module and exports a series of predicates that handle the addition of family relationships. Dynamic Declarations : :- dynamic checked/1. Allows the checked predicate to be dynamically updated, which is used in gender inference functions.","title":"Module and Dynamic Declarations"},{"location":"statements/#statement-definitions","text":"add_sibling(Sibling1, Sibling2) Checks if Sibling1 and Sibling2 are already siblings. If yes, it prints that the relationship exists. If not, it checks if such a sibling relationship is logically impossible (e.g., due to contradictory relationships). If impossible, it indicates so. If neither of these conditions is met, it asserts Sibling1 and Sibling2 as siblings in both directions ( Sibling1 as a sibling of Sibling2 and vice versa). add_brother(Brother, Sibling) First, it checks if Brother is already a brother of Sibling . If this relationship exists or is impossible, it responds accordingly. If Brother is not known to be male, it asserts his gender. Then it ensures that both Brother and Sibling are marked as siblings of each other. Finally, it tries to define genders from neutral relatives if needed. add_sister(Sister, Sibling) Similar to add_brother , but for establishing sister relationships. It asserts Sister 's gender as female if not already known. add_father(Father, Child) Checks if Father is already the father of Child . If this relationship is established or impossible, it responds accordingly. Asserts Father as male and as the parent of Child . Additionally, it handles cases where siblings have different mothers or fathers, ensuring consistency in parental relationships. add_mother(Mother, Child) Parallel to add_father but for mother relationships. It checks existing relationships, asserts gender, and handles complex family structures. add_parents(Parent1, Parent2, Child) Verifies if Parent1 and Parent2 are already parents of Child . If the relationship exists or is impossible, it indicates so. Asserts both Parent1 and Parent2 as parents of Child . add_grandmother(Grandmother, Grandchild) & add_grandfather(Grandfather, Grandchild) These predicates add grandmother and grandfather relationships, respectively. They check for existing relationships or impossibilities, assert gender, and then establish the grandparent relationship. add_daughter(Daughter, Parent) & add_son(Son, Parent) These predicates handle adding daughter or son relationships. They check for existing or impossible relationships, assert gender, and establish the parent-child relationship. add_child(Child, Parent) Checks if Child is already a child of Parent . If the relationship is established or impossible, it responds accordingly. Asserts the parent-child relationship. add_children(Children, Parent) Manages the addition of multiple children to a parent, handling each child individually. It processes lists, including handling special cases like empty strings or the word \"and.\" Each child is individually checked and added as a child of the parent. add_uncle(Uncle, NieceNephew) & add_aunt(Aunt, NieceNephew) These predicates add uncle or aunt relationships . They check for existing or impossible relationships, infer gender, and then assert the relationship.","title":"Statement Definitions"},{"location":"statements/#helper-definitions","text":"","title":"Helper Definitions"},{"location":"statements/#define_genders_from_neutralparent","text":"Purpose and Logic : Infers and asserts the gender of parents whose gender is not yet defined. Check & Mark : First, it checks if Parent has already been processed to avoid redundant checks. If not already checked, it marks Parent as checked. Find Other Parents : Retrieves all co-parents of Parent's children. Gender Inference : If any co-parent is known to be male, it invokes define_genders for further inference. If a co-parent is female, it calls define_genders_from_mother . If gender is unknown, no action is taken for that co-parent. Recursive Call : Applies the same logic to all retrieved co-parents, ensuring comprehensive gender inference across the family tree.","title":"define_genders_from_neutral(Parent)"},{"location":"statements/#define_gendersfather","text":"Purpose and Logic : Infers and asserts the gender of mothers related to a known male parent. Male Confirmation : Confirms that Father is male. Find Mothers : Identifies all co-parents of Father's children who are not yet identified as male or female. Assert Female : Asserts these co-parents as female. Recursive Gender Inference : Calls define_genders_from_mother for each co-parent to further infer genders in the family tree.","title":"define_genders(Father)"},{"location":"statements/#define_genders_from_mothermother","text":"Purpose and Logic : Similar to define_genders , but starts with a known female parent and infers male gender for co-parents. Female Confirmation : Ensures that Mother is female. Find Fathers : Identifies co-parents of Mother's children with an undefined gender. Assert Male : Asserts these co-parents as male. Recursive Gender Inference : Invokes define_genders for each male co-parent for further inference.","title":"define_genders_from_mother(Mother)"},{"location":"statements/#assert_as_maleperson-and-assert_as_femaleperson","text":"Purpose and Logic : These helper predicates assert a person as male or female, respectively, if their gender is not already defined. Check and Assert : Each predicate checks if the person's gender is not already defined. If undefined, it asserts the person as male or female. No Redundancy : Ensures no redundant assertions are made if the gender is already known.","title":"assert_as_male(Person) and assert_as_female(Person)"}]}